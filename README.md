# 파이썬 코딩 테스트 준비 😎

## 1. 리스트 관련 메서드

| 메서드명 | 사용법 | 설명 | 시간 복잡도 |
| --- | --- | --- | --- |
|append()|변수명.append()|리스트에 원소를 하나 삽입할 때 사용.| O(1)|
|sort()|변수명.sort()|기본 정렬 기능으로 오름차순으로 정렬한다.| O(NlogN)|
|sort()|변수명.sort(reverse = True)|내림차순으로 정렬한다.|O(NlogN)|
|reverse()|변수명.reverse()|리스트의 원소의 순서를 모두 뒤집어 놓는다.|O(N)|
| insert() | insert(삽입할 위치, 삽입할 값) | 특정한 인덱스 위치에 원소를 삽입할 때 사용한다. | O(N) |
| count() | 변수명.count(특정 값) | 리스트에서 특정한 값을 가지는 데이터의 개수를 셀 때 사용한다. | O(N) |
| remove() | 변수명.remove(특정 값) | 특정한 값을 갖는 원소를 제거하는데, 값을 가진 원소가 여러개면 하나만 제거한다. | O(N) |

- insert(), remove() 함수는 시간 복잡도가 O(N)
- 중간에 원소를 삽입한 뒤에, 리스트의 원소 위치를 조정해줘야 하기 때문
- insert() 함수 남발하면 '시간 초과'로 테스트를 통과하지 못할 수도 있다.

- 특정한 원소를 모두 제거하려면? > 파이썬은 이러한 함수를 기본적으로 제공해주지 않음

```python
  a = [1, 2, 3, 4, 5, 5, 5]
  remove_set = {3,5}  # 집합은 { } 로 표현  
  
  # remove_set에 포함되지 않은 값만을 저장
  
  result = [i for i in a if i not in remove_set] # not in 연산자 : 집합에 없으면 True
  print(result)
```

## 2. 문자열 자료형

- 문자열 변수를 초기화활 때는 큰따옴표("")나 작은 따옴표(')를 이용
- 문자열을 큰따옴표로 구성하는 경우, 내부적으로 작은따옴표를 포함할 수 있다. 그 반대도 가능
- 혹은 백슬래시(\)를 사용하면 Escape 문자열로 표현가능

  ```
  data = 'Hello World'
  print(data)
  
  data = "Don't you know \"Python\"?"
  print(data)
  ```
  
 - 문자열 연결 = '+'
 - 파이썬의 문자열은 내부적으로 리스트와 같이 처리된다.
 - 문자열은 여러 개의 문자가 합쳐진 리스트

   ```
   a = "ABCDEF"
    
   print(a[2 : 4 ])  # CD 출력
   ``` 

## 3. 튜플 자료형
- 파이썬의 튜플 자료형은 리스트와 거의 비슷한데 다음과 같은 차이가 있다.
  - 튜플은 한 번 선언된 값을 변경할 수 없다.
  - 리스트는 대괄호([])를 이용하지만, 튜플은 소괄호(())를 이용한다.

- 예를 들어 하나의 튜플 데이터를 선언한 다음, 값을 출력하고 튜플의 특정한 값을 변경해보자.

  ```
  a = (1, 2, 3, 4) # 튜플 자료형
  print(a) # (1, 2, 3, 4)
  
  a[2] = 7 # 에러 발생
  ```
  
- 튜플 자료형은 그래프 알고리즘을 구현할 때 자주 사용.
- 예를 들어 다익스트라 최단 경로 알고리즘처럼 최단 경로를 찾아주는 알고리즘의 내부에서는 우선순위 큐를 이용하는데,
  해당 알고리즘에서 우선순위 큐에 한 번 들어간 값은 변경되지 않는다. 그래서 그 우선순위 큐에 들어가는 데이터를 튜플로 구성하여 소스코드를 작성한다.
- 알고리즘을 구현하는 과정에서 일부러 튜플을 이용하게 되면 혹여나 자신이 알고리즘을 잘못 작성함으로써 변경하면 안 되는 값의 변경을 예방할 수 있다.
- 또한, 튜플은 리스트에 비해 상대적으로 공간 효율적이고, 일반적으로 각 원소의 성질이 서로 다를 때 주로 사용한다.
- 흔히 다익스트라 최단 경로 알고리즘에서는 '비용'과 '노드 번호'라는 서로 다른 성질의 데이터를, (비용, 노드 번호)의 형태로 함께 튜플로 묶어서 관리하는 것이 관례

## 4. 사전 자료형 (= Map 자료형 )

- 사전 자료형은 키(key)와 값(value)의 쌍을 데이터로 가지는 자료형
- 리스트나 튜플은 값을 순차적으로 저장한다는 특징이 있다.
- 예를 들어 리스트의 값이 [1,2,3]이라고 한다면, 첫 번째 원소는 a[0]으로 1이라는 값을 가진다.
- 하지만 사전 자료형은 키-값 쌍을 데이터로 가진다는 점에서, 우리가 원하는 변경 불가능한 데이터를 키로 사용할 수 있다.
- 사전 자료형이 사용되는 대표적인 예시는 사전(Dictionary)이다.

- 예를 들어 다음과 같이 키-값 쌍으로 구성되는 데이터를 담아야 한다면 어떻게 할 수 있을까?

| 키(Key) | 값(Value) |
| --- | --- |
| 사과 | Apple | 
| 바나나 | Banana | 
| 코코넛 | Coconut | 

- 키로 한글 단어를 넣고, 값으로 영어 단어를 넣어 '사과'의 영어 단어를 알고 싶다면 '사과'라는 키 값을 가지는 데이터에 바로 접근하면 된다.
- 파이썬의 사전 자료형은 내부적으로 '해시 테이블'을 이용하므로, 기본적으로 데이터의 검색 및 수정에 있어서 O(1)의 시간에 처리할 수 있다.
- 해시 테이블은 키-값 쌍으로 구성된 데이터를 처리함에 있어서 리스트보다 훨씬 빠르게 동작한다.

  ```Python
    data = dict() # 사전 자료형 생성
    
    # data['key'] = value
    data['사과'] = 'Apple'
    data['바나나'] = 'Banana'
    data[코코넛'] = 'Coconut'
    
    print(data)  # {'사과':'Apple', '바나나':'Banana', '코코넛':'Coconut'}
  ```
  
  
- 이러한 사전 자료형은 코딩 테스트에서도 자주 사용될 수 있다. 
- 예를 들어 학생의 번호가 1부터 10,000,000 까지 구성되어 있는 상황에서 최대 10,000명의 학생을 선택했다고 가정
- 이후에 특정한 학생 번호가 주어졌을 때 해당 학생이 선택되었는지를 어떻게 빠르게 알 수 있을까?
- 만약 리스트를 이용한다면, 1부터 10,000,000 까지의 각 번호가 '선택 되었는지를 저장할 수 있는' 리스트를 만들어아 한다.
- 다시 말해 1,000만 개 데이터를 저장할 수 있는 리스트를 만들어야 하므로 많은 메모리 공간이 낭비된다.
- 이 중 999만 개 가량의 데이터는 쓰이지 않을 것

- 하지만 사전 자료형을 이용하는 경우, 1,000만 개의 데이터를 담을 필요가 없으며 10,000개의 데이터만 사전 자료구조에 들어가므로 훨씬 적은 메모리 공간을 사용
- 사전 자료형에 특정한 원소가 있는지 검사할 때는 '원소 in 사전'의 형태로 사용할 수 있다.
- 이는 리스트나 튜플에 대해서도 사용할 수 있는 문법

  ```Python
    data = dict()
    data['사과'] = 'Apple'
    data['바나나'] = 'Banana'
    data['코코넛'] = 'Coconut'
    
    # 사전 자료형에서 특정 원소가 있는지 검사
    if '사과' in data :
      print("'사과'"를 키로 가지는 데이터가 존재합니다.")
  ```
  
- 파이썬에서 리스트, 문자열, 튜플 등 **순차적인 정보를 담는 자료형을 iterable 자료형이라고 한다.**
- in 문법은 이러한 iterable 자료형에 모두 사용이 가능하다.
  
  
  
## 사전 자료형 관련 함수
- 키와 값을 별도로 뽑아내기 위한 함수가 있다.
- 키 데이터만 뽑아서 리스트로 이용할 때는 keys() 함수를 이용하며, 값 데이터만을 뽑아서 리스트로 이용할 때는 values() 함수를 이용한다.
  
  
    ```Python
      data = dict()
      data['사과'] = 'Apple'
      data['바나나'] = 'Banana'
      data['코코넛'] = 'Coconut'
      
      # 키 데이터만 담은 리스트
      key_list = data.keys()
      # 값 데이터만 담은 리스트
      value_list = data.values()
      
      print(key_list)  # dict_keys(['사과', '바나나', '코코넛'])
      print(value_list)  # dict_values(['Apple', 'Banana', 'Coconut'])
    ```


## 5. 집합 자료형

- 파이썬에서는 집합을 처리하기 위한 집합 자료형을 제공한다.
- 집합은 기본적으로 리스트 혹은 문자열을 이용해서 만들 수 있는데, 집합은 다음과 같은 특징이 있다.
  - 중복을 허용하지 않는다.
  - 순서가 없다.

- 기존에 다루었던 리스트나 튜플은 순서가 있기 때문에, 인덱싱을 통한 자료형의 값을 얻을 수 있었다.
- 반면에 사전 자료형과 집합 자료형은 순서가 없기 때문에 인덱싱으로 값을 얻을 수 없다는 특징이 있다.
- 더불어, 집합 자료형에서는 키가 존재하지 않고, 값 데이터만을 담게 된다.
- 특정 원소가 존재하는지 검사하는 연산의 시간 복잡도는 사전 자료형과 마찬가지로 O(1) 이다.

- 사전 자료형에 대해서 다룰 때 언급했던 '학생 번호가 주어졌을 때 해당 학생이 선택되었는지 여부를 출력하는 문제'에서도 집합 자료형이 효과적으로 사용 될 수 있다.
- '특정한 데이터가 이미 등장한 적이 있는지 여부'를 체크할 때 매우 효과적이다.
- 집합 자료형을 초기화할 때는 set() 함수를 이용하거나, 중괄호({}) 안에 각 원소를 콤마(,)를 기준으로 구분해서 넣으면 된다


  ```python
  # 집합 자료형 초기화 방법 1
  data = set([1, 1, 2, 3, 4, 4, 5])
  print(data)
  
  # 집합 자료형 초기화 방법 2
  data = {1, 1, 2, 3, 4, 4, 5}
  print(data)
  ```

## 집합 자료형의 연산
- 기본적인 집합 연산으로는 합집합, 교집합, 차집합 연산이 있다.
- 파이썬은 이러한 집합 자료형의 연산에 대해서 다루고 있다.
- 집합 자료형 데이터 사이에서 합집합을 계산할 때는 '|'를 이용한다.
- 또한 교집합은 '&', 차집합은 '-'를 이용한다.

  ```python
  a = set([1, 2, 3, 4, 5])
  b = set([3, 4, 5, 6, 7])
  
  print(a | b) # {1, 2, 3, 4, 5, 6, 7}
  print(a & b) # {3, 4, 5}
  print(a - b) # {1, 2}
  
  
## 집합 자료형 관련 함수
- 집합 자료형 또한 다른 자료형과 마찬가지로 다양한 함수가 존재한다.
- 하나의 집합 데이터에 값을 추가할 때는 add() 함수
- update() 함수는 여러 개의 값을 한꺼번에 추가하고자 할 때 사용한다.
- 특정한 값을 제거할 때는 remove() 함수를 이용할 수 있다.
- 이때 add(), remove() 함수는 모두 시간 복잡도가 O(1) 이다.


  ```python
  data = set([1, 2, 3])
  print(data) # {1, 2, 3}
  
  # 새로운 원소 추가
  data.add(4)
  print(data) # {1, 2, 3, 4}
   
  # 새로운 원소 여러 개 추가
  data.update([5, 6])
  print(data) # {1, 2, 3, 4, 5, 6}
  
  # 특정한 값을 갖는 원소 삭제
  data.remove(3)
  print(data) # {1, 2, 4, 5, 6}
  ```
  
  
  ## 6. 문법
  
- 여러개의 데이터를 담는 자료형으로 리스트 튜플, 문자열, 사전과 같은 자료형이 존재
- 이 때 자료형 안에 어떠한 값이 존재하는지 확인하는 연산이 필요할 때가 있다.
  
- X in 리스트 : 리스트 안에 X가 들어가 있을 때 참(True)이다.
- X not in 문자열 : 문자열 안에 X가 들어가 있지 않을 때 참(True)이다.

- 조건문에서 실행될 소스코드가 한 줄인 경우, 굳이 줄 바꿈을 하지 않고도 간략하게 표현할 수 있다.

  ```python
  score = 85
  
  if score >= 80 : result = 'Success'
  else : result = 'Fail'
  ```

- 조건부 표현식을 이용하면 if~else 문을 한 줄에 작성해 사용할 수 있다.

  ```python
  score = 85
  result = 'Success' if score >= 80 else 'Fail'
  ```
  
- 특히 조건부 표현식은 리스트에 있는 원소의 값을 변경해서, 또 다른 리스트를 만들고자 할 때 매우 간결하게 사용할 수 있다.
- 예를 들어 리스트에서 특정한 원소의 값만을 없앤다고 해보자.

  ```python
  
  # 일반적인 코드 작성 방법
  
  a = [1, 2, 3, 4, 5, 5, 5]
  remove_set = {3, 5}
  
  result = []
  for i in a :
    if i not in remove_set :
      result.append(i)

  print(result) # [1, 2, 4]
  
  
  # 간략화한 버전
  
  a = [1, 2, 3, 4, 5, 5, 5]
  remove_set = {3, 5}
  
  result = [i for in a if i not in remove_set ]   # 'a if i not in remove_set' > 조건부 표현식
    
  print(result) # [1, 2, 4]
  
  ```
  
  
- 파이썬은 조건문 안에서 수학의 부등식을 그대로 사용할 수 있다.
- 예를 들어 "x > 0 and x < 20" 과 "0 < x < 20" 은 같은 결과를 반환.


## 반복문

- while 문 :  조건이 참일 때 한해서, 반복적으로 코드가 수행
- for문 : 리스트를 사용하는 대표적인 for문의 구조는 다음과 같다.
- in 뒤에 오는 데이터에 포함되어 있는 모든 원소를 첫 번째 인덱스부터 차례대로 하나씩 방문한다.
- in 뒤에 오는 데이터로는 리스트, 튜플, 문자열 등이 사용될 수 있다.


  ```python
    for 변수 in 리스트 :
      실행할 소스코드
  ```
  
- for문에서 수를 차례대로 나열할 때는 range()를 주로 쓰는데, range(시작 값, 끝 값 + 1) 형태로 사용.


  ```python
    result = 0
    
    # i 는 1부터 9까지의 모든 값을 순회
    for i in range(1, 10)
      result += i
  ```
  

- 또한 range()의 값으로 하나의 값만을 넣으면, 자동으로 시작 값은 0이 된다.
- 주로 리스트나 튜플 데이터의 모든 원소를 첫 번째 인덱스 부터 방문해야 할 때 이 방법을 사용.
- 반목문 안에서 continue를 만나면 프로그램의 흐름은 반복문의 처음으로 돌아간다.


## 함수

  ```python
  def 함수명(매개변수) :
    실행할 소스코드
    return 반환 값
    
    
  def add(a, b) :
    return a+b
```    

- 또한 함수를 호출하는 과정에서 인자를 넘겨줄 때, 파라미터의 변수를 직접 지정해서 값을 넣을 수 있다.
- 이 경우 매개변수의 순서가 달라도 상관없다는 점이 특징

```python
  def add(a, b) :
    return a+b
    
  add(b = 3, a = 7)
```

- 함수 안에서 함수 밖의 변수 데이터를 변경해야 하는 경우가 있다.
- 이때는 함수에서 global 키워드를 이용하면 된다.
- global 키워드로 변수를 지정하면, 해당 함수에서는 지역 변수를 만들지 않고, 함수 바깥에 선언된 변수를 바로 참조하게 된다.
- 아래 예시에서는 a라는 변수를 함수 안에서도 동일하게 접근하여 값을 변경하고 있다.
- 이를 위해, global 키워드가 사용된 것을 확인할 수 있다.


  ```python
   
   a = 0
   
   def func() :
       global a    # 함수 바깥의 a를 참조
       a += 1
    
   for i in range(10) :
       func()
   
   print(a)
  ```
  
  
- 파이썬에서는 람다 표현식을 사용할 수 있다.
- 람다 표현식을 이용하면 함수를 매우 간단하게 작성하여 적용할 수 있다.
- 특정한 기능을 수행하는 함수를 한 줄에 작성할 수 있다는 점이 특징
- 앞에서 정의했던 add() 함수와 같은 간단한 함수를 정의해야 할 때는 다음처럼 람다 표현식을 효과적으로 사용할 수 있다.


  ```python
    def add(a, b) :
      return a + b
      
    # 일반적인 add() 메서드 사용
    print(add(3,7))    # 10
    
    # 람다 표현식으로 구현한 add() 메서드
    print((lambda a,b : a + b)(3, 7)) # 10
  ```
  
 
  ## 7. 입출력
  
  - 알고리즘 문제 풀이의 첫 번째 단계는 데이터를 입력받는 것이다.
  - 알고리즘 문제의 경우 적절한 입력이 주어졌을 때, 그 입력을 받아서 적절한 알고리즘을 수행한 뒤의 결과를 출력하는 것을 요구
  - 보통 먼저 데이터의 개수가 첫 번째 줄에 주어지고, 처리할 데이터는 그 다음 줄에 주어지는 경우가 많다.


  ```
    입력 예시
    5    # 데이터의 개수
    65 90 75 34 99    # 처리할 데이터
  ```
  
- 파이썬에서 데이터를 입력받을 때는 input()을 이용한다.
- input()의 경우 한 줄의 문자열을 입력 받도록 해준다.
- 만약 파이썬에서 입력받은 데이터를 정수형 데이터로 처리하기 위해서는 문자열을 정수로 바꾸는 int() 함수를 사용해야 한다.
- 그리고 여러개의 데이터를 입력받을 때는 데이터가 공백으로 구분되는 경우가 많다.
- 입력 받은 문자열을 띄어쓰기로 구분하여 각각 정수 자료형의 데이터로 저장하는 코드의 사용 빈도가 매우 높다.
- 이때는 **list(map(int, input().slpit())**  을 이용하면 된다.
    - list(map(int, input().split())의 동작 과정을 알아보자.
    1. 가장 먼저 input()으로 입력 받은 문자열을 split() 이용해 **공백으로 나눈 리스트**로 바꾼 뒤에,
    2. map을 이용하여 해당 리스트의 모든 원소에 int() 함수를 적용한다. # map()은 리스트의 모든 원소에 적용해주는 함수인 듯
    3. 최종적으로 그 결과를 list()로 다시 바꿈으로써 입력받은 문자열을 띄어쓰기로 구분하여 각각 숫자 자료형으로 저장하게 되는 것.
    
    - 이 코드는 정말 많이 사용되므로, 반드시 외우고 있어야 한다.
    - 많은 문제는 공백, 혹은 줄 바꿈을 기준으로 데이터를 구분한다.
    - 파이썬에서는 구분자가 줄 바꿈인지 공백인지에 따라서 다른 처리를 요구한다.
    - 줄바꿈이라면 int(input())을 여러번 사용하면 된다.
    
    
    ```python
    
    > 입력 데이터
    > 5
    > 65 90 75 34 99
     
    
    # 입력을 위한 전형적인 소스코드
    
    # 데이터의 개수 입력
    n = int(input())    # 입력 값을 정수로 받는다.
    # 각 데이터를 공백으로 구분하여 입력
    data = list(map(int, input().split()))
    
    data.sort(reverse = True)
    print(data) # [99, 90, 75, 65, 34]
    
    ```

- 공백으로 구분된 데이터의 개수가 많지 않다면, 단순히 map(int, input().split())을 이용하는 것도 가능.    # 리스트로 만들지 않음
- 예를 들어 문제에서 첫째 줄에 n, m, k가 공백으로 구분되어 입력된다는 내용이 명시되어 있다면, 이 경우에는 다음과 같이 사용 가능

  ```python
  
  > 입력 데이터
  > 3 5 7
  
  # n, m, k를 공백으로 구분하여 입력
  n, m, k = map(int, input().split())    # 입력을 공백으로 분리하여 리스트로 만든 뒤, map으로 모든 원소에 int() 적용
  
  print(n, m, k)    
  
  ```

- 또한 문제를 풀다보면, 입력을 최대한 빠르게 받아야 하는 경우가 있다.
- 흔히 정렬, 이진 탐색, 최단 경로 문제의 경우 매우 많은 수의 데이터가 연속적으로 입력이 되곤 한다.
- 예를 들어 1,000만 개가 넘는 라인이 입력되는 경우, 입력을 받는 것만으로도 시관 초과를 받을 수 있다.
- 그래서 사용하는 언어별로 입력을 더 빠르게 받는 방법을 알고 있어야 한다.
- 파이썬도 마찬가지다. 입력의 개수가 많은 경우에는 단순히 input() 함수를 그대로 사용하지는 않는다.
- 파이썬의 기본 input() 함수는 동작 속도가 느려서 시간 초과로 오답 판정을 받을 수 있기 때문
- 이 경우, 파이썬의 sys 라이브러리에 정의되어 있는 **sys.stdin.readline()** 함수를 이용한다.

  ```python
  
  import sys    # sys 라이브러리 import
  sys.stdin.readline().rstrip()
  ```
  
- sys 라이브러리를 사용할 때는 한 줄 입력을 받고 나서 **rstrip() 함수를 꼭 호출해야 한다.**  
- readline()으로 입력하면 입력 후 엔터가 줄 바꿈 기호로 입력되는데, 이 공백 문자를 제거하러면 rstrip() 함수를 사용해야 한다.
- 이 또한 짧은 코드이니 관행적으로 외워서 사용하자.


  ```python
  
  # readline() 사용 소스코드 예시
  
  > 입력 데이터
  > Hello World↵ 
   
  
  # 문자열 입력받기
  data = sys.stdin.readline().rstrip()    # readline()은 엔터키를 줄바꿈 기호로 입력되는데, 이 공백문자를 rstrip()으로 제거
  print(data)    # Hello World
  
  ```
  
 
 - 출력을 할 때는 print() 함수를 이용하여 출력을 진행할 수 있다.
 - print()는 변수나 상수를 매개변수로 입력받아 이를 표준 출력으로 출력.
 - print()는 각 변수를 콤마(,)로 구분하여 매개변수로 넣을 수 있는데, 이 경우 각 변수가 띄어쓰기로 구분되어 출력된다.
 
     ```python
     # 출력할 변수들
     a = 1
     b = 2
     
     pirnt(a, b)     # 1 2
     ```
     
- 일부 문제의 경우 출력할 때 문자열과 수를 함께 출력해야 되는 경우가 있다. 이 경우 단순히 더하기 연산자(+)를 이용하여 문자열과 수를 더하면 오류가 발생

  ```python
  # 출력 시 오류가 발생하는 소스코드 예시
  # 출력할 변수들
  answer = 7
  
  print("정답은" + answer + "입니다.")
  ```

- 파이썬은 문자열과 수를 더할 때 자동으로 수 데이터가 문자열로 변환되지 않음

  ```python
  
  # 변수를 문자열로 바꾸어 출력하는 소스코드 예시
  # 출력할 변수들
  answer = 7
  
  print("정답은 " + str(answer) + "입니다")
  ```

- 각 변수를 콤마로 구분하여 출력하는 경우, 변수의 값 사이에 의도치 않은 공백이 삽입될 수 있다는 점을 신경 써주도록 하자.

  ```python
  # 출력할 변수들
  answer = 7
  
  print("정답은", str(answer), "입니다.")     # 정답은  7  입니다.
  


## 8. 주요라이브러리 문법과 유의점
- 파이썬의 일부 라이브러리는 잘못 사용하면 수행 시간이 비효율적으로 증가하므로 이 절에서 설명하는 내용을 잘 기억해두자.
- 표준 라이브러리란 특정한 프로그래밍 언어에서 자주 사용되는 표준 소스코드를 미리 구현해 놓은 라이브러리를 의미
- 코딩 테스트에서는 대부분 표준 라이브러리를 사용할 수 있도록 허용하므로 표준 라이브러리를 사용하면 소스코드 작성량에 대한 부담을 줄일 수 있다.


**코딩 테스트를 준비하며 반드시 알아야 하는 라이브러리는 6가지 정도이다.**

1. 내장 함수 : print(), input()과 같은 기본 입출력 기능부터 sorted()와 같은 정렬 기능을 포함하고 있는 기본 내장 라이브러리이다. 파이썬 프로그램을 작성할 때 없어서는 안 되는 필수적인 기능을 포함하고 있다.

2. itertools : 파이썬에서 반복되는 형태의 데이터를 처리하는 기능을 제공하는 라이브러리이다. **순열과 조합** 라이브러리를 제공한다.

3. heapq : 힙(Heap) 기능을 제공하는 라이브러리이다. 우선순위 큐 기능을 구현하기 위해 사용.

4. bisect : 이진 탐색(Binary Search) 기능을 제공하는 라이브러리

5. collections : 덱(deque), 카운터(counter) 등의 유용한 자료구조를 포함하고 있는 라이브러리이다.

6. math : 필수적인 수학적 기능을 제공하는 라이브러리이다. 팩토리얼, 제곱근, 최대공약수(GCD), 삼각함수 관련 함수부터 파이(pi)와 같은 상수를 포함.


## 내장 함수

- 별도의 import 명령어 없이 바로 사용할 수 있는 내장 함수가 존재.
- sum() : 리스트와 같은 iterable 객체가 주어졌을 때, 모든 원소의 합을 반환

- min() : 파라미터가 2개 이상 들어왔을 때 가장 작은 값을 반환.
- max() : 파라미터가 2개 이상 들어왔을 때 가장 큰 값을 반환.
- eval() : 수학 수식이  문자열 형식으로 들어오면 해당 수식을 계산한 결과를 반환

```python
  result = eval("(3+5) * 7")
  print(result)     # 56
```
- sorted() 함수는 iterable 객체가 들어왔을 때, 정렬된 결과를 반환. key 속성으로 정렬 기준을 명시할 수 있으며, reverse 속성으로 정렬된 결과 리스트를 뒤집을지의 여부를 설정할 수 있다.

```python
    # 리스트 [9, 1, 8, 5, 4]를 오름차순으로 정렬하는 예시와 내림차순으로 정렬하는 예시는 다음과 같다
    
    result = sorted([9, 1, 8, 5, 4])    # 오름차순으로 정렬
    print(result)
    result = sorted([9, 1, 8, 5, 4], reverse = True)    # 내림차순으로 정렬
    print(result)
```


- 파이썬에서는 리스트의 원소로 리스트나 튜플이 존재할 때 특정한 기준에 따라서 정렬을 수행할 수 있다.
- 정렬 기준은 key 속성을 이용해 명시할 수 있다.
- 에를 들어 [('홍길동', 35), ('이순신', 75), ('아무개', 50)]이 있을 때, 원소를 튜플의 두 번째 원소를 기준으로 내림차순 정렬하고자 한다면 다음과 같이 사용할 수 있다.

```python
    result = sorted([('홍길동', 35), ('이순신', 75), ('아무개', 50)], key = lambda x : x[1], reverse = True)
```    

- 리스트와 같은 iterable 객체는 기본으로 sort() 함수를 내장하고 있어서 굳이 sorted() 함수를 사용하지 않고도 sort() 함수를 사용해서 정렬할 수 있다.
- 이 경우 리스트 객체의 내부 값이 정렬된 값으로 바로 변경된다.

```python
# 리스트 [9, 1, 8, 5, 4] 를 오름차순으로 정렬하는 예시는 다음과 같다.
data = [9, 1, 8, 5, 4]
data.sort()
print(data)    # [1, 4, 5, 8, 9]
```


## itertools
- 파이썬에서 반복되는 데이터를 처리하는 기능을 포함하고 있는 라이브러리
- permutations(순열) : 리스트와 같은 iterable 객체에서 r개의 데이터를 뽑아 일렬로 나열하는 모든 경우를 계산해 준다.
- permutations는 클래스이므로 객체 초기화 이후에는 리스트 자료형으로 변환하여 사용한다.
- 리스트 ['A', 'B', 'C'] 에서 3개 (r = 3)를 뽑아 나열하는 모든 경우를 출력하는 예시는 다음과 같다.

```python

  from itertools import permutations
  
  data = ['A', 'B', 'C']
  
  result = list(permutations(data, 3))  # 모든 순열 구하기    # 객체 초기화 후 리스트 자료형으로 변환해서 사용

  print(result)   #  ABC, ACB, BAC, BCA, CAB, CBA
```

- combinations(조합) : 리스트와 같은 iterable 객체에서 r개의 데이터를 뽑아 순서를 고려하지 않고 나열하는 모든 경우(조합)
- (순서를 고려하지 않는다 = 순서에 의미를 두지 않겠다 = 순서가 달라도 같은 걸로 간주하겠다. ex) ab = ba)
- combinations는 클래스이므로 객체 초기화 이후에는 리스트 자료형으로 변환하여 사용한다.
- 리스트 ['A', 'B', 'C'] 에서 2개 (r = 2)를 뽑아 나열하는 모든 경우를 출력하는 예시는 다음과 같다. 

```python
    from itertools import combinations
    
    data = ['A', 'B', 'C']    # 데이터 준비
    result = list(combinations(data, 2))    # 2개를 뽑는 모든 조합 구하기
    
    print(result)    # AB, AC, BC
```


- product는 permutations와 같이 리스트와 같은 iterable 객체에서 r개의 데이터를 뽑아 일렬로 나열하는 모든 경우 (순열) 을 계산한다.
- 다만 원소를 중복하여 뽑는다.
- product 객체를 초기화 할 때는 뽑고자 하는 데이터의 수를 repeat 속성값으로 넣어준다.
- product는 클래스이므로 객체 초기화 이후에는 리스트 자료형으로 변환하여 사용한다.
- product = 중복을 허용하여 repeat 개의 원소를 뽑기
- 리스트 ['A', 'B', 'C'] 에서 중복을 포함하여 2개 (r = 2)를 뽑아 나열하는 모든 경우를 출력하는 예시는 다음과 같다. 


```python
    from itertools import product
    
    data = ['A', 'B', 'C']
    result = list(product(data, repeat = 2)  # 2 개를 뽑는 모든 순열 구하기 (중복 허용), 그냥 2개씩 뽑을 수 있는 모든 경우의 수
    
    print(result)    # AA, AB, AC, BA, BB, BC, CA, CB, CC
 ```
 
 
    
- combinations_with_replacement(조합) : combinations와 같이 리스트와 같은 iterable 객체에서 r개의 데이터를 뽑아 순서를 고려하지 않고 나열하는 모든 경우(조합)
- (순서를 고려하지 않는다 = 순서에 의미를 두지 않겠다 = 순서가 달라도 같은 걸로 간주하겠다. ex) ab = ba)
- combinations_with_replacement 클래스이므로 객체 초기화 이후에는 리스트 자료형으로 변환하여 사용한다.
- 리스트 ['A', 'B', 'C'] 에서 2개 (r = 2)를 뽑아 나열하는 모든 경우를 출력하는 예시는 다음과 같다. 

```python
    from itertools import combinations_with_replacement
    
    data = ['A', 'B', 'C']    # 데이터 준비
    result = list(combinations_with_replacement(data, 2))    # 2개를 뽑는 모든 조합 구하기
    
    print(result)    # AA, AB, AC, BB, BC, CC
```
  


## heapq 
- 파이썬에서는 힙 기능을 위해 heapq 라이브러리를 제공한다. heapq는 다익스트라 최단 경로 알고리즘을 포함해 다양한 알고리즘에서 **우선순위 큐** 기능을 구현하고자 할 때 사용된다.
- 파이썬의 힙은 최소 힙으로 구성되어 있으므로(최소 값을 가진 원소가 가장 위에 위치), 단순히 원소를 힙에 전부 넣었다가 빼는 것만으로도 시간 복잡도 O(NlogN)에 오름차순 정렬이 완료된다.
- 보통 최소 힙 자료구조의 최상단 원소는 항상 '가장 작은 원소'이기 때문이다.
- **힙에 원소를 삽입할 때는 heapq.heappush(), 힙에서 원소를 꺼내고자 할 때는 heapq.heappop() 메서드를 이용한다.**
- 힙 정렬을 heapq로 구현하는 예제를 통해 heapq의 사용 방법을 알아보자.

```python
    import heapq
    
    def heapsort (iterable) :    # iterable 객체를 매개변수로 받음
        h = []    # 데이터를 넣을 배열
        result = []
        
        # 모든 원소를 차례대로 힙에 삽입
        
        for value in iterable :
            heapq.heappush(h, value) = h를 힙으로 사용하여 원소를 삽입
            
        # 힙에 삽입된 모든 원소를 차례대로 꺼내어 담기
        for i in range(len(h)) :    # 힙의 원소의 개수 만큼 반복
            result.append(heapq.heappop(h))    
        return result
        
    
    result = heapsort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0])
    print(result)    # 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
    
```


- 또한 파이썬에서는 최대 힙을 제공하지 않는다.
- 따라서 heapq 라이브러리를 이용하여 최대 힙을 구현해야 할 때는 원소의 부호를 임시로 변경하는 방식을 사용한다.
- 힙에 원소를 삽입하기 전에 잠시 부호를 반대로 바꾸었다가, 힙에서 원소를 꺼낸 뒤에 다시 원소의 부호를 바꾸면 된다.
- 이러한 방식으로 최대 힙을 구현하여 내림차순 힙 정렬을 구현하는 예시는 다음과 같다.
    
    
    
```python
    import heapq
    
    def heapsort (iterable) :    # iterable 객체를 매개변수로 받음
        h = []    # 데이터를 넣을 배열
        result = []
        
        # 모든 원소를 차례대로 힙에 삽입
        
        for value in iterable :
            heapq.heappush(h, -value) = h를 힙으로 사용하여 원소를 삽입
            
        # 힙에 삽입된 모든 원소를 차례대로 꺼내어 담기
        for i in range(len(h)) :    # 힙의 원소의 개수 만큼 반복
            result.append(-heapq.heappop(h))    
        return result
        
    
    result = heapsort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0])
    print(result)    # 9, 8, 7, 6, 5, 4, 3, 2, 1, 0
    
```


## bisect
- 파이썬에서는 이진 탐색을 쉽게 구현할 수 있도록 bisect 라이브러리를 제공한다. bisect 라이브러리는 **"정렬된 배열"** 에서 특정한 원소를 찾아야 할 때 매우 효과적으로 사용된다.
- bisect 라이브러리에서는 **bisect_left() 함수와 bisect_right() 함수**가 가장 중요하게 사용되며, 이 두 함수는 시간 복잡도 O(logN)에 동작한다.

- bisect_left(a, x) : 정렬된 순서를 유지하면서 리스트 a 에 데이터 x 를 삽입할 가장 왼쪽 인덱스를 찾는 메서드
- bisect_right(a, x) : 정렬된 순서를 유지하면서 리스트 a 에 데이터 x 를 삽입할 가장 오른쪽 인덱스를 찾는 메서드

- 예를 들어 정렬된 리스트 a = [1, 2, 4, 4, 8] 이 있을 때, 새롭게 데이터 4를 삽입하려 한다고 가정하자.
- 이때 bisect_left(a, 4)와 bisect_right(a, 4)는 각각 인덱스 값으로 2와 4를 반환한다.

```python
  from bisect import bisect_left, bisect_right
  
  a = [1, 2, 4, 4, 8]
  x = 4
  
  print(bisect_left(a, x))    # 2
  print(bisect_right(a, x))    # 4
```

- 또한 bisect_left() 함수와 bisect_right() 함수는 '정렬된 리스트'에서 '값이 특정 범위에 속하는 원소의 개수'를 구하고자 할 때, 효과적으로 사용될 수 있다.
- 아래의 count_by_range(a, left_value, right_value) 함수를 확인해보자
- 이는 정렬된 리스트에서 값이 [left_value, right_value]에 속하는 데이터의 개수를 반환한다.
- 다시 말해 원소의 값을 x 라고 할 때, left_value <= x <= right_value인 원소의 개수를 O(logN)으로 빠르게 계산할 수 있다.

```python
    from bisect import bisect_left, bisect_right
    
    # 값이 [left_value, right_value]인 데이터의 개수를 반환하는 함수
    def count_by_range(a, left_value, right_value) :
       right_index = bisect_right(a, right_value)   # right_value 값의 오른쪽 인덱스를 반환
       left_index = bisect_left(a, left_value)    # left_value 값의 왼쪽 인덱스를 반환
       
       return right_index - left_index
       
   # 리스트 선언
   a = [1, 2, 3, 3, 3, 3, 4, 4, 8, 9]
   
   # 값이 4인 데이터 개수 출력
   print(count_by_range(a, 4, 4))    # 8 - 6 = 2
   
   # 값이 [-1, 3] 범위에 있는 데이터의 개수 출력
   print(count_by_range(a, -1, 3))    # 6 - 0 = 6
   
```



## collections 

- 파이썬의 collections 라이브러리는 유용한 자료구조를 제공하는 표준 라이브러리다.
- collections 라이브러리의 기능 중에서 코딩 테스트에서 유용하게 사용되는 클래스는 deque와 Counter 이다.


## deque - 양 끝에 삽입, 삭제를 할 수 있는 Queue

- 보통 파이썬에서는 deque를 사용해 큐를 구현한다.
- 별도로 제공되는 Queue 라이브러리가 있는데 일반적인 큐 자료구조를 구현하는 라이브러리는 아니다.
- 따라서 deque를 이용해 큐를 구현해야 한다는 점을 기억하자.

- 기본 리스트 자료형은 데이터의 삽입, 삭제 등의 다양한 기능을 제공한다.
- 리스트가 있을 때 중간에 특정한 원소를 삽입한느 것도 가능하다.
- 하지만 리스트 자료형은 append() 메서드로 데이터를 추가하거나, pop() 메서드로 데이터를 삭제할 때 '가장 뒤쪽 원소'를 기준으로 수행된다.
- 따라서 앞쪽에 있는 원소를 처리할 때에는 리스트에 포함된 데이터의 개수에 따라서 많은 시간이 소요될 수 있다.
- 리스트에서 앞쪽에 있는 원소를 삭제하거나 앞쪽에 새 원소를 삽입할 때의 시간 복잡도는 O(N)이다.

- deque는 리스트 자료형과 다르게 인덱싱, 슬라이싱 등의 기능은 사용할 수 없다.
- 다만, 연속적으로 나열된 데이터의 시작 부분이나 끝 부분에 데이터를 삽입하거나 삭제할 때는 매우 효과적으로 사용될 수 있다.
- 따라서 deque를 큐 자료구조로 이용할 때, 원소를 삽입할 때에는 append()를 사용하고 원소를 삭제할 때에는 popleft()를 사용하면 된다.
- 그러면 먼저 들어온 원소가 항상 먼저 나가게 된다.
- 리스트 [2, 3, 4]의 가장 앞쪽과 뒤쪽에 원소를 삽입하는 예시는 다음과 같다.

```python
    from collections import deque
    
    data = deque([2, 3, 4])
    data.appendleft(1)    # 첫번째 인덱스에 원소 삽입
    data.append(5)    # 마지막 인덱스에 원소 삽입
    
    print(data)    # deque([1, 2, 3, 4, 5])
    print(list(data))    # 리스트 자료형으로 변환 [1, 2, 3, 4, 5]
```


## Counter

- 파이썬 collections 라이브러리의 Counter는 등장 횟수를 세는 기능을 제공한다. 구체적으로 리스트와 같은 iterable 객체가 주어졌을 때, 해당 객체 내부의 원소가 몇 번씩 등장했는지를 알려준다.
- 따라서 원소별 등장 횟수를 세는 기능이 필요할 때 짧은 소스코드로 이를 구현할 수 있다.


```python
    from collections import Counter
    
    counter = Counter(['red', 'blue', 'red', 'green', 'blue', 'blue'])    # 리스트를 매개변수로 전달
    
    print(counter['blue'])    # blue가 등장한 횟수 출력 - 3
    print(counter['green'])    # green이 등장한 횟수 출력 - 1
    print(dict(counter))    # 사전 자료형으로 변환 (키-등장 횟수) - {'red' : 2, 'blue}
```



## math
- math 라이브러리는 자주 사용되는 수학적인 기능을 포함하고 있는 라이브러리
- 팩토리얼, 제곱근, 최대공약수(GCD) 등을 계산해주는 기능을 포함, 수학 계산을 요구하는 문제를 만났을 때 효과적으로 사용될 수 있다.

```python
   import math
   
   print(math.factorial(5))    # 5 팩토리얼을 출력 - 120

```

- sqrt(x) 함수는 x의 제곱근을 반환
```python
   import math
   
   print(math.sqrt(7))    # 7의 제곱근을 출력 - 2.6457513....
   

```

- 최대 공약수를 구해야 할 때는 math 라이브러리의 gcd(a, b) 함수를 이용
- 이 함수는 a와 b의 최대 공약수를 반환한다.

```python
   import math
   
   
   print(math.gcd(21, 14))    # 21과 14의 최대 공약수 - 7
```

- 수학 공식에서 자주 등장하는 상수가 필요할 때에도 math 라이브러리를 사용할 수 있다.
- math 라이브러리는 파이(pi)나 자연상수 e를 제공

```python
   import math
   
   
   print(math.pi)    # 파이 출력
   print(math.e)    # 자연상수 e 출력
```

     
  
    
    



  

